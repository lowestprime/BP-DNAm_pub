ggrastr::rasterise(geom_point(aes(x = expected, y = observed), color = "blue4", size = 0.5), dpi = 300) +  # Rasterized points
labs(title = paste0("QQ Plot (qqplotr) - ", plot_prefix),
x = expression(Expected~~-log[10](italic(p))),
y = expression(Observed~~-log[10](italic(p)))) +
theme_minimal(base_size = 12, base_family = "Arial") +
theme(plot.title = element_text(hjust = 0.5))
},
ggfastman = function(data) {
# Adjust data for ggfastman
data_fastman <- data
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
ggfastman::fast_qq(data_fastman$pval,
title = paste0("QQ Plot (ggfastman) - ", plot_prefix),
speed = "f") +  # Enable fast rendering in ggfastman
theme_minimal(base_size = 12, base_family = "Arial") +
theme(plot.title = element_text(hjust = 0.5))
}
)
# Generate and save plots using rasterization for ggplot2 and qqplotr
for (method_name in names(plot_methods)) {
plot_func <- plot_methods[[method_name]]
qq_plot <- plot_func(gwasResults)
# Save plot as optimized SVG with svglite
svglite::svglite(file.path(plot_dir, paste0(plot_prefix, "_qqplot_", method_name, ".svg")),
system_fonts = list(sans = "Arial"),
fix_text_size = FALSE)
print(qq_plot)
dev.off()
}
cat("Optimized QQ plots saved successfully as SVG in", plot_dir, "\n")
gc()
#### Comprehensive GWAS Analysis and Visualization Script ####
# Date: 9/7/2024
# This script allows you to generate GWAS plots manually, one at a time,
# by running individual code blocks in RStudio.
# -----------------------------
# Load Required Packages
# -----------------------------
# Ensure required installers are available
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE)) install.packages(p)
# List of packages and their installation sources
packages <- list(
"manhplot"    = "cgrace1978/manhplot",
"hudson"      = "anastasia-lucas/hudson",
"locuszoomr"  = "myles-lewis/locuszoomr",
"fastman"     = "kaustubhad/fastman",
"ggrepel"     = "slowkow/ggrepel",
"ggmanh"      = "bioc",
"biovizBase"  = "github",
"ggbio"       = "bioc",
"scattermore" = "exaexa/scattermore",
"ggfastman" =   "roman-tremmel/ggfastman"
)
# Install and load packages
for (pkg in names(packages)) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
if (packages[[pkg]] == "bioc") {
# Install development version of Bioconductor packages
BiocManager::install(pkg, version = "devel")
} else if (packages[[pkg]] == "github") {
# Special case for biovizBase
devtools::install_github("lawremi/biovizBase")
} else {
# Install GitHub packages
devtools::install_github(packages[[pkg]], dependencies = T, force = T)
}
# Load Packages
if (!require("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
ggplot2, conflicted, data.table, qqplotr, CMplot, pheatmap, ComplexHeatmap, devtools,
TrumpetPlots, ensembldb, AnnotationFilter, GenomicRanges, biovizBase, ggbio, svglite,
manhplot, hudson, locuszoomr, fastman, fs, ggmanh, ggrepel, tidyr, dplyr, purrr,
ggfastman, ggforce, ggrastr, scattermore
)
# Resolve conflicts
conflicts_prefer(
dplyr::filter, dplyr::select, dplyr::rename, dplyr::mutate,
dplyr::recode, dplyr::slice, dplyr::setdiff, fs::path
)
# -----------------------------
# List .mlma Files Organized by Directory
# -----------------------------
# Define Parent Directory Containing .mlma Files
mlma_dir <- '/u/project/lhernand/cobeaman/ABCD_Longitudinal_Subcortical_Imaging_GWAS/Analysis/GCTA_GWAS/Processed_Data/Results/'
# Load and process files
mlma_files <- dir_ls(mlma_dir, glob = "*.mlma", recurse = TRUE)  # Assign to mlma_files
if (!length(mlma_files)) stop("No .mlma files found.")
# Process file paths into a tibble with directory and file info
df <- tibble(full_path = mlma_files) %>%
mutate(path = map_chr(full_path, ~ paste(tail(strsplit(.x, "/")[[1]], 3), collapse = "/"))) %>%
separate(path, into = c("dir1", "dir2", "file"), sep = "/") %>%
arrange(dir1, dir2, file) %>%
group_by(dir1, dir2) %>%
mutate(file_num = row_number()) %>%
ungroup()
#### Comprehensive GWAS Analysis and Visualization Script ####
# Date: 9/7/2024
# This script allows you to generate GWAS plots manually, one at a time,
# by running individual code blocks in RStudio.
# -----------------------------
# Load Required Packages
# -----------------------------
# Ensure required installers are available
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE)) install.packages(p)
# List of packages and their installation sources
packages <- list(
"manhplot"    = "cgrace1978/manhplot",
"hudson"      = "anastasia-lucas/hudson",
"locuszoomr"  = "myles-lewis/locuszoomr",
"fastman"     = "kaustubhad/fastman",
"ggrepel"     = "slowkow/ggrepel",
"ggmanh"      = "bioc",
"biovizBase"  = "github",
"ggbio"       = "bioc",
"scattermore" = "exaexa/scattermore",
"ggfastman" =   "roman-tremmel/ggfastman"
)
# Install and load packages
for (pkg in names(packages)) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
if (packages[[pkg]] == "bioc") {
# Install development version of Bioconductor packages
BiocManager::install(pkg, version = "devel")
} else if (packages[[pkg]] == "github") {
# Special case for biovizBase
devtools::install_github("lawremi/biovizBase")
} else {
# Install GitHub packages
devtools::install_github(packages[[pkg]], dependencies = T, force = T)
}
# Load Packages
if (!require("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
ggplot2, conflicted, data.table, qqplotr, CMplot, pheatmap, ComplexHeatmap, devtools,
TrumpetPlots, ensembldb, AnnotationFilter, GenomicRanges, biovizBase, ggbio, svglite,
manhplot, hudson, locuszoomr, fastman, fs, ggmanh, ggrepel, tidyr, dplyr, purrr,
ggfastman, ggforce, ggrastr, scattermore
)
# Resolve conflicts
conflicts_prefer(
dplyr::filter, dplyr::select, dplyr::rename, dplyr::mutate,
dplyr::recode, dplyr::slice, dplyr::setdiff, fs::path
)
# -----------------------------
# List .mlma Files Organized by Directory
# -----------------------------
# Define Parent Directory Containing .mlma Files
mlma_dir <- '/u/project/lhernand/cobeaman/ABCD_Longitudinal_Subcortical_Imaging_GWAS/Analysis/GCTA_GWAS/Processed_Data/Results/'
# Load and process files
mlma_files <- dir_ls(mlma_dir, glob = "*.mlma", recurse = TRUE)  # Assign to mlma_files
if (!length(mlma_files)) stop("No .mlma files found.")
# Process file paths into a tibble with directory and file info
df <- tibble(full_path = mlma_files) %>%
mutate(path = map_chr(full_path, ~ paste(tail(strsplit(.x, "/")[[1]], 3), collapse = "/"))) %>%
separate(path, into = c("dir1", "dir2", "file"), sep = "/") %>%
arrange(dir1, dir2, file) %>%
group_by(dir1, dir2) %>%
mutate(file_num = row_number()) %>%
ungroup()
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE)) install.packages(p)
# List of packages and their installation sources
packages <- list(
"manhplot"    = "cgrace1978/manhplot",
"hudson"      = "anastasia-lucas/hudson",
"locuszoomr"  = "myles-lewis/locuszoomr",
"fastman"     = "kaustubhad/fastman",
"ggrepel"     = "slowkow/ggrepel",
"ggmanh"      = "bioc",
"biovizBase"  = "github",
"ggbio"       = "bioc",
"scattermore" = "exaexa/scattermore",
"ggfastman" =   "roman-tremmel/ggfastman"
)
install.packages(p)
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE)) install.packages(p)
# List of packages and their installation sources
packages <- list(
"manhplot"    = "cgrace1978/manhplot",
"hudson"      = "anastasia-lucas/hudson",
"locuszoomr"  = "myles-lewis/locuszoomr",
"fastman"     = "kaustubhad/fastman",
"ggrepel"     = "slowkow/ggrepel",
"ggmanh"      = "bioc",
"biovizBase"  = "github",
"ggbio"       = "bioc",
"scattermore" = "exaexa/scattermore",
"ggfastman" =   "roman-tremmel/ggfastman"
)
install.packages(p)
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE))
install.packages(p)
for (p in c("devtools", "BiocManager")) if (!require(p, quietly = TRUE)) install.packages(p)
install.packages(p)
BiocManager()
?BiocManager
BiocManager::version()
# Ensure required installers are available
for (p in c("devtools", "BiocManager")) {
if (!requireNamespace(p, quietly = TRUE)) {
install.packages(p)
}
library(p, character.only = TRUE)
}
generate_qq_plots <- function(gwasResults, plot_dir, plot_prefix) {
# Prepare data
data_fastman <- gwasResults
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
# Filter out invalid p-values and apply threshold for small p-values
data_fastman <- data_fastman[data_fastman$pval > 1e-300 & data_fastman$pval < 1, ]
# Generate the base QQ plot without points
qq_base <- ggfastman::fast_qq(
data_fastman$pval,  # Use filtered observed p-values
speed = "slow",     # Slow mode to ensure accuracy
pointsize = 0,      # Do not render points yet (we'll add them with scattermore)
linecolor = "deeppink",
ci_color = "steelblue",
ci_alpha = 0.3,
log10 = TRUE,
inflation_method = "median",
title = paste0("QQ Plot - ", plot_prefix)
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Add rasterized points using scattermore
qq_plot <- qq_base +
scattermore::geom_scattermore(aes(
x = -log10(ppoints(nrow(data_fastman))),
y = -log10(data_fastman$pval)
), color = "black", pointsize = 1.5, pixels = c(2048, 2048))  # Adjust resolution
# Save the plot as an optimized SVG
svg_file_path <- file.path(plot_dir, paste0(plot_prefix, "_qqplot_rasterized.svg"))
svglite(svg_file_path, width = 7, height = 7)
print(qq_plot)
dev.off()
cat("Optimized QQ plot saved successfully as SVG in", plot_dir, "\n")
}
# Generate QQ plots
generate_qq_plots(gwasResults, plot_dir, plot_prefix)
# Resolve conflicts
conflicts_prefer(
dplyr::filter, dplyr::select, dplyr::rename, dplyr::mutate, data.table::first,BiocGenerics::combine,
dplyr::recode, dplyr::slice, dplyr::setdiff, fs::path, BiocGenerics::combine, ggplot2::stat_qq_line
)
for (p in c("devtools", "BiocManager", "conflicted")) {
if (!requireNamespace(p, quietly = TRUE)) {
install.packages(p)
}
library(p, character.only = TRUE)
}
# Resolve conflicts
conflicts_prefer(
dplyr::filter, dplyr::select, dplyr::rename, dplyr::mutate, data.table::first,BiocGenerics::combine,
dplyr::recode, dplyr::slice, dplyr::setdiff, fs::path, BiocGenerics::combine, ggplot2::stat_qq_line
)
# List of packages and their installation sources
packages <- list(
"manhplot"    = "cgrace1978/manhplot",
"hudson"      = "anastasia-lucas/hudson",
"locuszoomr"  = "myles-lewis/locuszoomr",
"fastman"     = "kaustubhad/fastman",
"ggrepel"     = "slowkow/ggrepel",
"ggmanh"      = "bioc",
"biovizBase"  = "github",
"ggbio"       = "bioc",
"scattermore" = "exaexa/scattermore",
"ggfastman"   = "roman-tremmel/ggfastman",
"fastqq"      = "gumeo/fastqq"
)
# Install and load packages
for (pkg in names(packages)) {
if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
if (packages[[pkg]] == "bioc") {
# Install development version of Bioconductor packages
BiocManager::install(pkg, version = "devel")
} else if (packages[[pkg]] == "github") {
# Special case for biovizBase
devtools::install_github("lawremi/biovizBase")
} else {
# Install GitHub packages
devtools::install_github(packages[[pkg]], dependencies = T, force = T)
}
# Load Packages
if (!require("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
ggplot2, data.table, qqplotr, CMplot, pheatmap, ComplexHeatmap, devtools,
TrumpetPlots, ensembldb, AnnotationFilter, GenomicRanges, biovizBase, ggbio, svglite,
manhplot, hudson, locuszoomr, fastman, fs, ggmanh, ggrepel, tidyr, dplyr, purrr,
ggfastman, ggforce, ggrastr, scattermore, fastqq
)
# -----------------------------
# List .mlma Files Organized by Directory
# -----------------------------
# Define Parent Directory Containing .mlma Files
mlma_dir <- '/u/project/lhernand/cobeaman/ABCD_Longitudinal_Subcortical_Imaging_GWAS/Analysis/GCTA_GWAS/Processed_Data/Results/'
# Load and process files
mlma_files <- dir_ls(mlma_dir, glob = "*.mlma", recurse = TRUE)  # Assign to mlma_files
if (!length(mlma_files)) stop("No .mlma files found.")
# # Process file paths into a tibble with directory and file info
# df <- tibble(full_path = mlma_files) %>%
#   mutate(path = map_chr(full_path, ~ paste(tail(strsplit(.x, "/")[[1]], 3), collapse = "/"))) %>%
#   separate(path, into = c("dir1", "dir2", "file"), sep = "/") %>%
#   arrange(dir1, dir2, file) %>%
#   group_by(dir1, dir2) %>%
#   mutate(file_num = row_number()) %>%
#   ungroup()
#
# # Group by directories and collapse file names, print each directory once
# df %>%
#   group_by(dir1, dir2) %>%
#   reframe(
#     dir_path = paste(dir1, dir2, sep = "/"),
#     files = paste0(file_num, ". ", file, collapse = "\n")
#   ) %>%
#   distinct(dir_path, files) %>%  # Ensure distinct groups
#   pwalk(function(dir_path, files) {
#     cat(dir_path, "\n", files, "\n\n")
#   })
#
# # Print the final summary of total directories and files
# cat("\n", n_distinct(df$dir1, df$dir2), "dirs,", nrow(df), "files\n")
# -----------------------------
# Helper Functions
# -----------------------------
# Function to Process GWAS Results
process_gwas_results <- function(file) {
# Read the data and perform the operations step by step
gwasResults <- fread(file, header = TRUE)[
# Rename columns where necessary
, setnames(.SD, old = c("Chr", "bp", "p", "SNP", "beta", "se", "freq"),
new = c("CHR", "BP", "P", "SNP", "Beta", "SE", "Freq"),
skip_absent = TRUE)][
# Filter for valid P values and numeric CHR and BP columns
!is.na(P) & is.finite(P) & !is.na(CHR) & !is.na(BP) & CHR %in% 1:22
]
# Convert CHR and BP to numeric if not already
gwasResults[, `:=`(CHR = as.numeric(CHR), BP = as.numeric(BP))]
return(gwasResults)
}
# -----------------------------
# Load and Process GWAS Results from a Specific File
# -----------------------------
# Select a specific .mlma file to process
file_to_process <- mlma_files[1]
# Alternatively, specify the file path directly
# file_to_process <- "/path/to/your/file.mlma"
# Process the selected GWAS results file
gwasResults <- process_gwas_results(file_to_process)
# Check if data is loaded correctly
if (nrow(gwasResults) == 0) {
warning("No valid data in file:", file_to_process)
} else {
cat("Data loaded successfully for file:", file_to_process, "\n")
# Create plot directory and prefix
plot_dir <- file.path(dirname(file_to_process), 'plots')
dir.create(plot_dir, showWarnings = FALSE, recursive = TRUE)
plot_prefix <- sub("\\.mlma$", "", basename(file_to_process))
}
# -----------------------------
# Generate Plots
# -----------------------------
# --- Generate Optimized QQ Plot with ggfastman ---
generate_qq_plots <- function(gwasResults, plot_dir, plot_prefix) {
# Prepare data
data_fastman <- gwasResults
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
# Filter out invalid p-values and apply threshold for small p-values
data_fastman <- data_fastman[data_fastman$pval > 1e-300 & data_fastman$pval < 1, ]
# Generate the base QQ plot without points
qq_base <- ggfastman::fast_qq(
data_fastman$pval,  # Use filtered observed p-values
speed = "slow",     # Slow mode to ensure accuracy
pointsize = 0,      # Do not render points yet (we'll add them with scattermore)
linecolor = "deeppink",
ci_color = "steelblue",
ci_alpha = 0.3,
log10 = TRUE,
inflation_method = "median",
title = paste0("QQ Plot - ", plot_prefix)
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Add rasterized points using scattermore
qq_plot <- qq_base +
scattermore::geom_scattermore(aes(
x = -log10(ppoints(nrow(data_fastman))),
y = -log10(data_fastman$pval)
), color = "black", pointsize = 1.5, pixels = c(2048, 2048))  # Adjust resolution
# Save the plot as an optimized SVG
svg_file_path <- file.path(plot_dir, paste0(plot_prefix, "_qqplot_rasterized.svg"))
svglite(svg_file_path, width = 7, height = 7)
print(qq_plot)
dev.off()
cat("Optimized QQ plot saved successfully as SVG in", plot_dir, "\n")
}
# Generate QQ plots
generate_qq_plots(gwasResults, plot_dir, plot_prefix)
if (!require("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(
ggplot2, data.table, qqplotr, CMplot, pheatmap, ComplexHeatmap, devtools,
TrumpetPlots, ensembldb, AnnotationFilter, GenomicRanges, biovizBase, ggbio, svglite,
manhplot, hudson, locuszoomr, fastman, fs, ggmanh, ggrepel, tidyr, dplyr, purrr,
ggfastman, ggforce, ggrastr, scattermore, fastqq, hexbin
)
generate_qq_plots <- function(gwasResults, plot_dir, plot_prefix) {
# Prepare data
data_fastman <- gwasResults
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
# Filter out invalid p-values and apply threshold for small p-values
data_fastman <- data_fastman[data_fastman$pval > 1e-300 & data_fastman$pval < 1, ]
# Calculate expected values for QQ plot
expected <- -log10(ppoints(nrow(data_fastman)))
observed <- -log10(data_fastman$pval)
# Hexagonal binning
hex_data <- hexbin(expected, observed, xbins = 100)
# Plot hexagonal bins
qq_plot <- ggplot() +
geom_hex(data = as.data.frame(hex_data), aes(x = x, y = y), bins = 50) +
geom_abline(slope = 1, intercept = 0, color = "deeppink") +
labs(x = expression(Expected~~-log[10](italic(p))),
y = expression(Observed~~-log[10](italic(p))),
title = paste0("QQ Plot - ", plot_prefix)) +
theme_minimal(base_size = 12)
# Save the plot as an SVG
svg_file_path <- file.path(plot_dir, paste0(plot_prefix, "_hexbin_qqplot.svg"))
svglite(svg_file_path, width = 7, height = 7)
print(qq_plot)
dev.off()
cat("Optimized QQ plot saved successfully as SVG in", plot_dir, "\n")
}
# Generate QQ plots
generate_qq_plots(gwasResults, plot_dir, plot_prefix)
generate_qq_plots <- function(gwasResults, plot_dir, plot_prefix) {
# Prepare data for ggfastman
data_fastman <- gwasResults
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
# Filter out invalid p-values and set a reasonable lower threshold
data_fastman <- data_fastman[data_fastman$pval > 1e-300 & data_fastman$pval < 1, ]
# Cap the number of plotted points to avoid excessive file size (e.g., 50,000 points)
if (nrow(data_fastman) > 50000) {
set.seed(123)  # Ensure reproducibility
data_fastman <- data_fastman[sample(1:nrow(data_fastman), 50000), ]  # Downsample
}
# Generate QQ plot using ggfastman (no pruning)
qq_plot <- ggfastman::fast_qq(
data_fastman$pval,  # Use filtered and downsampled p-values
speed = "slow",     # Slow mode to keep points vectorized
pointsize = 1.5,    # Adjust point size for better visibility
linecolor = "deeppink",
ci_color = "steelblue",
ci_alpha = 0.3,
log10 = TRUE,
inflation_method = "median",
title = paste0("QQ Plot - ", plot_prefix)
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Save the plot as an optimized SVG
svg_file_path <- file.path(plot_dir, paste0(plot_prefix, "_qqplot_capped.svg"))
svglite(svg_file_path, width = 7, height = 7)
print(qq_plot)
dev.off()
cat("Downsampled QQ plot saved successfully as SVG in", plot_dir, "\n")
}
# Generate QQ plots
generate_qq_plots(gwasResults, plot_dir, plot_prefix)
generate_qq_plots <- function(gwasResults, plot_dir, plot_prefix) {
# Prepare data for ggfastman
data_fastman <- gwasResults
colnames(data_fastman)[colnames(data_fastman) == "P"] <- "pval"
# Filter out invalid p-values and set a reasonable lower threshold
data_fastman <- data_fastman[data_fastman$pval > 1e-300 & data_fastman$pval < 1, ]
# Prioritize the most significant p-values by keeping the smallest ones
# Retain the top 5% smallest p-values and downsample the remaining data
significant_threshold <- quantile(data_fastman$pval, 0.05)  # Top 5% of p-values
significant_points <- data_fastman[data_fastman$pval <= significant_threshold, ]
non_significant_points <- data_fastman[data_fastman$pval > significant_threshold, ]
# Downsample the non-significant points to 50,000
if (nrow(non_significant_points) > 50000) {
set.seed(123)  # Ensure reproducibility
non_significant_points <- non_significant_points[sample(1:nrow(non_significant_points), 50000), ]
}
# Combine significant and downsampled non-significant points
final_data <- rbind(significant_points, non_significant_points)
# Generate QQ plot using ggfastman
qq_plot <- ggfastman::fast_qq(
final_data$pval,  # Use filtered and downsampled p-values
speed = "slow",   # Slow mode to keep points vectorized
pointsize = 1.5,  # Adjust point size for better visibility
linecolor = "deeppink",
ci_color = "steelblue",
ci_alpha = 0.3,
log10 = TRUE,
inflation_method = "median",
title = paste0("QQ Plot - ", plot_prefix)
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(hjust = 0.5, face = "bold"))
# Save the plot as an optimized SVG
svg_file_path <- file.path(plot_dir, paste0(plot_prefix, "_qqplot_significant.svg"))
svglite(svg_file_path, width = 7, height = 7)
print(qq_plot)
dev.off()
cat("QQ plot with prioritized significant points saved successfully as SVG in", plot_dir, "\n")
}
# Generate QQ plots
generate_qq_plots(gwasResults, plot_dir, plot_prefix)
setwd("~/project-lhernand/ABCD_Longitudinal_Subcortical_Imaging_GWAS/Analysis/GCTA_GWAS")
install.packages("GGally")
install.packages("ggplot2")
options(warn = -1)
suppressPackageStartupMessages(library(GGally))
gc()
